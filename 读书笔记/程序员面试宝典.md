**面试题：用一个表达式判断一个数X是否为2的整数次幂，不可使用循环语句**

解析：若X是2的整数次幂，那么X-1之后与X&的结果是0

答案：!(X&(X-1));
***
**面试题：下面代码**

		int f(int x, int y)
		{
			return (x&y)+((x^y)>>1);
		}
(729,271)=__

解析：x&y使取相同位与，这个结果是x和y相同位的一半，x^y是取x和y的不同位，右移相当于除2，所以这个函数的功能就是取两个数的平均值

答案：500

***
##C和C++的关系
**题目：在C++程序中调用被C编译器编译后的函数，为什么要加extern "C"?**

答案：C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字和C语言不同。
C++提供了C链接交换指定符号extern "C"解决名字匹配问题

**评价一下C和C++的各自特点**

答案：C是一种结构化语言，重点在于数据结构和算法，C程序的设计首先考虑的是如何通过一个过程，对输入进行运算处理得到输出，而对于C++，首先考虑的是如何构造一个对象模型，让这个模型能够切合与之对应的问题领域，这样就可以通过获取对象的状态信息得到输出或实现过程控制。

##预处理、const与sizeof

**用一个宏定义获取结果体中某个变量相对结构体首地址的偏移量**
答案：`#define FIND(struc, e) (size_t)&(((struc*)&0)->e)`
**用预处理指令#define声明一个常数，用以表明一年有多少秒（忽略闰年问题）**

解析：
涉及以下知识点：
* \#define的语法知识
* 要懂得预处理器将为你计算常数表达式的值
* 意识到这个表达式将使一个16位的整型数溢出，因此要用到长整型符号L，告知编译器这个常数使长整型数

如果在表达式中用到UL（无符号长整型），那么就有了一个好的起点

答案：`#define SECONDS_PEＲ＿YEAR (60*60*24*365)UL`

###const

**const有什么用途，至少说明两点**

解析：在C程序中，const的用法主要有定义常量，修饰函数参数，修饰函数返回值。在C++中，它还可以修饰函数的定义体，定义类中的某个成员函数为恒态函数，即不改变类中的数据成员

答案：（1）可以定义只读变量；（2）const可以修饰函数参数和返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防以外的变动，能提高程序的健壮性。

**const和define的区别**

答案：const比define有更多的优点：
* const常量有数据类型，而宏定义常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只是进行文本替换，没有类型安全检查，并且在文本替换的过程中可能产生意料不到的错误（边际效应）
* 有些集成的调试工具可以对const常量进行调试，但不能对宏常量进行调试，在C++程序中只使用const常量而不使用宏常量，即const常量完全可以取代宏常量

**一个空类占多少内存，多重继承的空类呢？**
解析：
```
#include <iostream>
#include <cmemory>
#include <cassert>

using namespace std;
class A{};
class A2{};
class B:public A{};
class C:public virtual B{};
class D:public A,public A2{};
int main()
{
	cout << sizeof(A) << endl;
	cout << sizeof(B) << endl;
	cout << sizeof(C) << endl;
	cout << sizeof(D) << endl;
	return 0;
}
```
输出结果是1 1 4 1
这说明空类占一个字节，单一继承的空类空间也是1，多重继承的空类空间还是1，虚继承涉及虚表（虚指针），所以占4个字节

答案：一个空类占1，多重继承的空类所占空间还是1

**内联函数和宏的差别**

答案：内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接被镶嵌到目标代码中。而宏只是简单的文本替换。
内联函数要做参数类型检查，这是内联函数跟宏相比的优势。
inline是指嵌入代码，就是在调用函数的地方不是跳转，而是直接把代码写到那里。对于短小的代码来说，inline可以带来一定效率的提升，而且和C时代的宏函数相比，inline更安全可靠。可是这个是以增加空间消耗为代价的。
inline一般只适用于如下情况：
（1）一个函数不断被重复调用。
（2）函数只有简单的几行，且函数内不包含for、while、switch语句

##指针与引用

**指针与引用的区别**
答案：
（1）非空区别。在任何情况下都不能使用指向空值的引用。一个引用必须总是指向某些对象。因此如果你使用一个变量并让他指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时就应该把变量声明为指针，因为这样你可以赋空值给该变量。相反，如果变量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为引用。不存在指向空值引用这个事实意味着使用i弄的代码效率比使用指针要高。
（2）合法性区别。在使用引用前不需要测试它的合法性。但是，在使用指针之前，总应该测试，防止其为空。
（3）可修改性区别。指针与引用的另一个重要区别就是指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后都不能改变，但是指定的对象其内容可以改变
（4）应用区别。总得来说，在以下情况下应该使用指针：一是考虑到存在不指向任何对象的可能（在这种情况下，能够设置指针为空），二是需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么应该使用引用。

**C++有了malloc/free,为什么还要new/free**
malloc和free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可以用于动态内存的申请和释放。
对于非内部数据类型的对象而言，只用malloc/free无法满足动态对象的要求，对象在创建的时候要自动执行构造函数，对象在消亡之前要自动调用析构函数，由于malloc/free是哭喊念书而不是运算符，不在编译器控制范围之内，不能够把执行构造函数和析构函数的任务强加给malloc/free
因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理和释放内存工作的运算符delete。new/delete不是库函数，而是运算符

**为什么析构函数可以是虚函数，而构造函数不可以是虚函数**
答案：虚函数采用一种虚调用的办法。虚调用是一种可以在只有部分信息的信息的情况下工作的机制，特别允许我们调用一个只知道接口而不知道其准确对象类型的函数。但是如果要构建一个对象，你势必要知道对象的准确类型，因此构造函数不能为虚函数。

（1）虚函数对应一个虚表指针，可是这个虚表指针其实存储在对象的内存空间的。问题来了，如果构造函数是虚函数，就要通过虚表指针调用，可是对象还没有实例化，也就是内存空间还没有，无法找到虚表指针，所以构造函数不能是虚函数

**死锁产生的四个必要条件**
* 互斥条件：一个资源每次只能被一个进程使用。
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
* 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
* 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

