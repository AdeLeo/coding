#C陷阱与缺陷
##第一章
###词法分析中的“贪心法”
&emsp;每一个符号应该包含尽可能多的字符。
> 如果(编译器的)输入流截止至某个字符之前都已经被分解为一个个符号，那么下一个符号将包括从该字符之后可能组成一个符号的最长字符串。

**需要注意的是**
除了字符串与字符常量，符号的中间不能嵌有空白（空格符、制表符和换行符）。例如，==是单个符号，而= = 则是两个符号，下面的表达式
`a---b`
与表达式
`a -- - b`
的含义相同，而与在
`a - -- b`
的含义不同。同样的，如果/是为判断下一个符号而读入的第一个字符，而/之后紧接着\*，那么无论上下文如何，这两个字符都将被当做一个符号/\*，表示一段注释的开始。

***
###整型常量
&emsp;如果一个整型常量的第一个字符是数字0，那么该常量将被视作八进制数。因此10和010的含义截然不同
***
###字符和字符串
&emsp;用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。
&emsp;用双引号引起的字符串，代表的确是一个指向无名数组起始字符的指针，该数组被双引号之间的字符以及一个额外的二进制值为零的字符'\0'初始化
`char *slash = '/';`
在编译时将会生成一条错误信息，因为'/'并不是一个字符指针。

整型数（一般为16位或32位）的存储空间可以容纳多个字符（一般为8位），因此有的C编译器允许在一个字符常量（以及字符串常量）中包括多个字符。也就是所，用'yes'代替"yes"不会被该编译器检测到

> 在Borland c++ v5.5和LCC v3.6中采取的做法时，忽略多余的字符，最后的整数值即第一个字符的整数值；而在Visual C++ 6.0和GCC v2.95中采取的做法是，依次用后一个字符覆盖前一个字符，最后得到的整数值即最后一个字符的整数值

***
##第二章
###理解函数声明
`(*fp)()`
ANSI C标准允许程序员将上式简写成fp()，但是一定要记住这种写法只是一种简写形式
在表达式(\*fp)()中，\*fp两侧的括号非常重要，因为函数运算符()的优先级高于单目运算符\*。
***
###运算符的优先级问题
`if(flags & FLAG != 0)`
上式是一个错误的语句。因为!=运算符的优先级要高于&运算符，所以上式实际上被解释为：
`if(flags & (FLAG != 0))`

`r = hi << 4 + low;`
加法运算的优先级要比移位运算的优先级高
因此实际上上式相当于：
`r = hi << (4 + low);`

优先级最高者其实并不是真正意义上的运算符，包括：数组下标、函数调用操作符各结构成员选择操作符。它们都是从左往右结合
**() [] -> .**

单目运算符的优先级仅次于上述运算符。在所有的真正意义上的运算符中，它们的优先级最高。因为函数调用的优先级要高于单目运算符的优先级，所以如果p使一个函数指针，要调用p所指向的函数，必须这样写：(\*p)()。如果写成\*p()，

**单目运算符是自右往左结合，因此*p++会被编译器解释成\*(p++)**

优先级比单目运算符要低的，接下来就是双目运算符，双目运算符中，**算术运算符**的优先级最高，**移位运算符**次之，**关系运算符**再次之，接着是**逻辑运算符**，**赋值运算符**，最后是**条件运算符**。

我们需要记住最重要的两点：
> 1. 任何一个逻辑运算符的优先级低于任何一个关系运算符
> 2. 移位运算符的优先级比算术运算符要低，但是比关系运算符要高。

***
##语义“陷阱”
###整数溢出
C语言中存在两类整数算术运算，有符号运算与无符号运算。如果算术运算符的一个操作数是有符号整数，另一个是无符号整数，那么有符号整数会被转换成无符号整数。当两个操作数都是有符号整数时，“溢出”就可能发生，而且“溢出”的结果时未定义的。当一个运算的结果发生“溢出”时，做出任何假设都是不安全的。

例如:
假定a和b使两个非负整型变量，我们需要检查a+b是否会“溢出”。一种想当然的方式是：
`
if (a + b < 0)
	complain();
`

这并不能正常运行。当a+b确实发生“溢出”时，所有福安雨结果如何的假设都不在可靠。

一种正确的方式是将a和b都强制转换成无符号整数：
`if((unsigned)a + (unsigned)b > INT_MAX) complain();`

不需要用到无符号算术运算的另一种可行方法是：
`if(a > INT_MAX - b) complain();`


##连接
###什么是连接器
C语言中的一个重要思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。

典型的连接器把编译器或汇编器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。

连接器通常把目标模块看成是由一组外部对象组成的。每个外部对象代表着机器内存中的某个部分，并通过一个外部名称来识别。因此，程序中的每个函数和每个外部变量，如果没有被声明为static，就都是一个外部对象。

大多数连接器都禁止同一个载入模块中的两个不同外部对象拥有相同的名称。然而，在多个目标模块整合成一个载入模块时，这些目标模块可能就包含了同名的外部对象。连接器的一个重要工作就是处理这类命名冲突。

处理命名冲突的最简单编发就是干脆完全禁止。对于外部对象时函数的情形，这种做法当然正确，一个程序如果包括两个同名的不同函数，编译器根本就不应该接收。而对于外部对象时变量的情形，问题就变得有些困难了。不同的连接器对这种情形有着不同的处理方式。

连接器的输入时一组目标模块和库文件。连接器的输出时一个载入模块。连接器读入目标模块和库文件，同时生成载入模块。对每个目标模块中的每个外部对象，连接器都要检查载入模块，看是否已经有同名的外部对象。如果没有，连接器就将该外部对象添加到载入模块中；如果有，连接器就要开始处理命名冲突。

除了外部对象之外，目标模块中还可能包括了对其他模块中的外部对象的引用。在连接器生成载入模块的过程中，它必须同时记录这些外部对象的引用。当连接器读入一个目标模块时，它必须解析出这个目标模块中定义的所有外部对象的引用，并做出标记说明这些外部对象不再是未定义的。

###检查外部类型
假定一个C程序，有两个源文件组成。一个文件中包含外部变量n的声明：
`extern int n;`
另一个文件包含外部变量n的定义：
`long n;`
这里假定两个语句都不在任何一个函数体内，因此n使外部变量。
这是一个无效的C程序，因为同一个外部变量名在两个不同文件中被声明为不同的类型。
然而，大多数C语言实现却不能检测出这种错误。

当这个程序运行时，发生什么情况呢？
1、 C语言编译器足够“聪明”，能够检测到这一类型冲突。
2、 C语言实现对int类型的数值与long类型的数值在内部表示上时一样的。尤其时在32位计算机上，一般都是如此处理。在这种情况下，程序很可能正常工作，就好像n在两个文件中都被声明为long(或int)类型一样。
3、 变量n的两个实例虽然要求的存储空间的大小不同，但是它们共享存储哦你关键的方式却恰好能够满足这样的条件：赋给其中一个的值，对另一个也是有效的。这是很可能发生的。
4、 变量n的两个实例共享存储空间的方式，使得对其中一个赋值时，其效果相当于同时给另一个赋值了完全不同的值。在这种情况下，程序将不能正常工作。

##库函数
###返回整数的getchar函数

```
#include <stdio.h>

main()
{
	char c;
	
	while((c = getchar()) != EOF)
		putchar(c);
}
```
getchar函数在一般情况下返回的是标准文件中的下一个字符，当没有输入时返回EOF。

程序中的c使char类型，而不是int类型。这意味着c无法容下所有可能的字符，特别是，可能无法容下EOF

可能发生的情况：
一种是某些合法的输入字符在被“截断”后使得c的取值和EOF一样；另一种可能时，c根本不可能取得EOF这个值。

###更新文件顺序
为了保持与过去不能同时进行读写操作的程序的向下兼容性，一个输入操作不能随后直接紧跟一个输出操作，反之亦然。如果要同时进行输入和输出操作，必须在其中插入fseek函数的调用

```
FILE *fp;
struct record rec;
...
while(fread((char *)&rec, sizeof(rec), 1, fp) == 1)
{
	/*对rec执行某些操作*/
	if(/*rec必须被重新写入*/)
	{
		fseek(fp, -(long)sizeof(rec), 1);
		fwrite((char *)&rec, sizeof(rec), 1, fp);
	}
}
```

这段代码仍然可能运行失败

问题出在：
如果一个记录需要被重新写入文件，也就是说，fwrite函数得到执行，对这个文件执行的下一个操作将是循环开始的fread函数。因为在fwrite函数调用和fread函数调用之间缺少了一个fseek函数调用，所以无法进行上述操作。解决办法是：
```
while(fread((char *)&rec, sizeof(rec), 1, fp) == 1)
{
	/*对rec执行某些操作*/
	if(/*rec必须被重新写入*/)
	{
		fseek(fp, -(long)sizeof(rec), 1);
		fwrite((char *)&rec, sizeof(rec), 1, fp);
		fseek(fp, 0L, 1);
	}
}
```

第二个fseek函数虽然看上去什么也没做，但它改变了文件的状态，使得文件现在可以正常的进行读取了。

###缓冲输出与内存分配
程序输出有两种方式：一种是即时处理方式，另一种是先暂时存起来，然后大块写入的方式，前者往往造成较高的系统负担。

这种控制能力一般是通过库函数setbuf函数实现的。如果buf是一个大小适当的字符数组，那么

`setbuf(stdout, buf);`

语句将通知输入/输出库，所有写入到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区，直到buf缓冲区被填满或者程序员直接调用fflush（对于由写操作打开的文件，调用fflush将导致输出缓冲区的内容被实际地写入该文件），buf缓冲区中的内容才实际写入stdout中。缓冲区的大小由系统头文件<stdio.h>中的BUFSIZ定义。

```
#include <stdio.h>

main()
{
	int c;
	char buf[BUFSIZ];
	setbuf(stdout, buf);
	
	while((c = getchar()) != EOF)
	{
		putchar(c);
	}
}
```

这个程序是错的
因为程序中对库函数setbuf的调用，通知了输入/输出库所有字符的标准输出应该首先缓存在buf中。要找到问题出自何处，我们不妨思考一下buf缓冲区最后一次被清空是在什么时候？答案是在main函数结束之后，作为程序交回控制给操作系统之前C运行时库所必须进行的清理工作的一部分。但是，在此之前buf字符数组已经被释放了！

要解决这种类型的错误有两种办法：
第一种办法是让缓冲数组称为静态数组，既可以直接显式声明buf为静态：
`static char buf[BUFSIZ];`
也可以把buf声明完全移到main函数之外。第二种办法是动态分配缓冲区，在程序中不会主动释放分配的缓冲区
```
char *malloc();
setbuf(stdout, malloc(BUFSIZ));
```

如果malloc函数调用失败，将返回一个空指针。setbuf函数的第二个参数取值可以为空指针，此时标准输出不需要缓冲。在这种情况下，程序仍然能够工作，只不过速度比较慢而已。

###库函数signal
在许多C语言实现中，信号是真正意义上的“异步”。从理论上说，一个信号可能在c程序执行期间的任何时刻发生。需要特别强调的是，信号甚至可能出现在某些复杂库函数（如malloc）的执行过程中。因此，从安全的角度考虑，信号的处理函数不应该调用上述类型的库函数。

例如，假设malloc函数的执行过程被一个信号打断。此时，malloc函数用来跟踪可用内存的数据结构可能只有部分被更新。如果signal处理函数在调用malloc函数，结果可能时malloc函数用到的数据结构signal处理函数的唯一安全、可移植的操作就是打印一条错误消息，然后使用longjmp或exit立即退出程序。

##预处理器
预处理器使得编程者简化某些工作，它的重要性：
* 我们需要将某个特定数量（例如，某个数据表的大小）在程序中出现的所有实例统统加以修改。我们希望能够通过在程序中之改动一处数值，然后重新编译就可以实现。我们只需要将这个数值定义为一个显式常量，然后在程序中需要的地方使用这个常量即可。而且，预处理器还能够很容易地把所有常量定义都集中在一起，这样要找到这些常量也非常容易。

* 大多数C语言实现在函数调用时都会带来重大的系统开销。因此我们希望有这样的一种程序块，它看上去像一个函数，但却没有函数调用的开销。

**宏只是对程序的文本起作用**
**宏提供了一种对组成C程序的字符进行变换的方式，而并不作用于程序中的对象**

使用宏的另一个危险是，宏展开可能产生非常庞大的表达式，占用的空间远远超过了编程者所期望的空间。

###宏并不是类型定义
宏的一个常见用法，使多个不同的变量类型可在同一个地方说明：
`#define FOOTYPE struct foo`
`FOOTYPE a`
`FOOTYPE b,c`
这样，编程者只需要在程序中改动一行代码，即可改变a、b、c的类型，而与在程序的什么地方声明无关

宏定义的这种用法有一个优点--可移植性，得到了所有C编译器的支持
但是我们最好还是用typedef


##可移植性缺陷
1、3种类型的整数其长度是非递减的。也就是说，short型整数容纳的值肯定能够被int整数容纳，int型整数容纳的值也肯定能够被long型整数容纳。对于一个特定的C语言实现来说，并不需要实际支持3种不同长度的整数，但可能不会让short型整数大于int型整数，而int型整数大于long型整数。
2、一个普通（int类型）整数足够大以容纳任何数组下标。
3、字符长度由硬件特性觉得。

可以用一个int型整数来表示一个数据表格的大小或者数组的下标。但如果一个变量需要存放可能时千万数量级的数值，可移植性最好的办法就是声明该变量为long类型，但在这种情况下我们定义一个“新的”类型无疑更为清晰：
`typedef long tenmil;`

###字符是有符号整数还是无符号整数
现代大多数计算机都支持8位字符，因此大多数现代C编译器都把字符实现为8位整数。然而，并非所有的编译器都按照同样的方式来解释8位数值。

只有在我们需要把一个字符值转换为一个较大的整数时，这个问题才变得重要起来。而在其他情况下，结果都是已定义的：多余的位将被简单地“丢弃”。编译器在转换char类型到int类型时，需要做出选择：应该将字符作为有符号数还是应该无符号数处理？如果时前一种情况，编译器在将char类型的数拓展到int类型时，应该同时复制符号位；而如果时后一种情况下，编译器只需要在多余的位上直接填充0即可。

一个常见的错误认知：如果c是一个字符变量，使用（unsigned）c就可以得到与c等价的无符号整数。这是会失败的，<font color=0#ffffff>**因为在将字符c转换为无符号整数时，c将首先被转换成int类型整数，而此时可能得到非预期的结果。**</font>

正确的方式是使用语句(unsigned char)c，因为一个unsigned char类型的字符在转换为无符号整数时无需首先转换为int型类型整数，而是直接进行转换。

###移位运算符
1、向右移位的时候，空出来的位是填0，还是由符号位的副本填充
2、移位计数（即移位操作的位数）允许的取值范围是什么

第一个问题很简单，但有时却是与具体的C语言实现有关。如果被移位的对象时无符号数，那么空出来的位将被0填充。如果被移位的对象时有符号数，那么C语言实现既可以用0填充空出来的位，也可以用符号位的副本填充空出来的位，那么可以将操作的变量声明为无符号类型。那么空出来的位都会被置0.

第二个问题的答案同样简单：如果被移位的对象长度是n位，那么移位计数必须大于或等于0，而严格小于n。因此，不可能做到单词操作中将某个数值中的所有位都移出。为什么要有这个限制呢？因为只要加上了这个限制条件，我们就能够在硬件上高效地实现移位运算。

**需要注意的是，即使C实现将符号位复制到空出来的位中，有符号整数的向右移位运算也并不等同于除2的某次幂。要证明这一点，让我们考虑(-1)>>1，这个操作的结果一般不可能为0，但是(-1)/2在大多数C实现上求值的结果都是0.这意味着以除法代替移位操作，将可能导致程序运行速度大大减慢。**

###除法运算时发生的截断
假定我们让a除以b，商为q， 余数为r：
q = a / b;
r = a % b;
这里，不妨假定b大于0

我们希望a、b、q、r之间维持怎样的关系呢？
1、 最重要的一点，我们希望q * b+ r == a，因为这是余数的定义
2、 如果我们改变a的正负号，我们希望这会改变q的符号，但这不会改变q的绝对值
3、 当b>0时，我们希望保证r>=0且r<b，例如，如果余数用于哈希表的索引，确保它是一个有效的索引值很重要

这三条不可能同时成立

考虑一个简单的例子：
3/2商为1，余数是1.此时第一条满足，（-3）/2如果要满足第二条性质，答案应该是-1，但如果这样，余数就必定是-1，这样第三条性质就无法满足了。

因此C语言或其他语言在实现整数除法截断运算时，必须放弃上述三条中的至少一条。大多数选择放弃第三条，而改为要求余数与被除数的正负号相同。
`
h = n % HASHSIZE;
`
此时，如果n为负数，h可能也为负数。
```
h = n % HASHSIZE;
if(h < 0)
	h += HASHSIZE;
```

更好的做法是，程序设计时就避免n为负数的情况出现，并且声明n为无符号数

###首先释放，然后重新分配
malloc realloc free
realloc需要把指向一块已分配内存的区域指针以及这块内存新的大小作为参数传入，就可以调整这块内存区域为新的大小，这个过程中有可能涉及到内存的拷贝。

例外：unix系统参考手册：
> realloc函数把指针ptr所指向内存块的大小调整为size字节，返回一个指向调整后内存块（可能该内存块已经被移动过了）的指针。假定这块内存原来的大小为oldsize，新的大小为newsize，这两个数之间较小者为min(oldsize,newsize)，那么内存块中较小者部分存储的内容将保持不变。
> 
> 如果ptr指向的是一块最近一次调用malloc、realloc或calloc分配的内存，即使这块内存已经被释放了，realloc函数仍然可以工作。因此，可以调节free，malloc和realloc的调用顺序，充分利用malloc函数的搜索策略来压缩存储空间。

也就是说，这一实现允许在某块内存被释放后重新分配大小，前提是内存重分配足够早。

###可移植性的一个例子
```
void printNum(long n, void (*p)())
{
	if(n < 0)
	{
		(*p)('-');
		n = -n;
	}

	if(n >= 10)
	{
		printNum(n/10, p);
	}
	(*p)((int)(n%10)+'0');
}
```

一致性问题：
第一个问题出在该程序把n的10进制表示的末尾数字转换为字符形式时所用的方法。加上'0'来得到对应的字符表示却不一定核实。程序的加法操作实际上假定了在机器的字符集中数字时顺序排列、没有间隔的，但对某些机器可能会出错。
要避免这个问题时使用一张代表数字的字符表。因为一个字符串常量可以用来代表一个字符数组，所以在数组名出现的地方都可以用字符串常量来替换。
"0123456789"[n%10]
是合法的

改写：
```
void printNum(long n, void (*p)())
{
	if(n < 0)
	{
		(*p)('-');
		n = -n;
	}

	if(n >= 10)
	{
		printNum(n/10, p);
	}
	(*p)((int)(n%10)+'0');
}

```

第二个问题与n < 0的情形有关。上面的程序首先打印出一个符号，然后把n设置成-n。这个赋值操作有可能发生溢出。因为基于2的补码计算机一般允许表示的负数取值范围要大于正数的取值范围。具体来说，就是如果一个long型整数有k位以及一个符号位，该long类型整数能够表示-2^k却不能表示2^k。

要解决这个问题，有好几种办法。最明显的一种办法就是把-n赋给一个unsigned long类型的变量，然后对这个变量进行操作。但是我们不能对-n求值，因为这样做会引起溢出！

无论是对基于1的补码还是2的补码的机器，改变一个正整数的符号都可以确保不会发生溢出。唯一的麻烦就是来自于当改变一个负数的符号的时候。因此，如果我们能够保证不将n转换成对应的正数，那么我们就能避免这一问题。

我们当然可以做到以同样的方式来处理正数和负数。只不过n为负数时需要打印出一个符号。要做到这一点，程序在打印符号之后强制n未负数，并且让所有的算术运算都是针对负数进行的。也就是说，我们必须保证打印符号的操作所对应程序只被执行一次，最简单的办法就是把程序拆成两个函数。

```
void printNeg(long n, void (*p)())
{
	if(n <= -10)
		printNeg(n/10,p);
	(*p)("0123456789"[-(n%10)]);
}

void printNum(long n, void (*p)())
{
	if(n < 0)
	{
		(*p)('-');
		printNeg(n, p);
	}
	else
		printNeg(-n, p);
}
```

这样写还是存在移植性问题，n/10和n%10分别代表首个数字和末位数字，当然还需要改变符号
当整数除法运算中一个操作数为负时，它的行为表现和具体的实现有关。

因此，当n为负数时，n%10可能是正数

要解决这个问题，我们可以创建两个临时变量来分别保存商和余数。在除法运算完成之后，检查余数是否在合理的范围内；如果不是，则适当调整两个变量。

```
void printNeg(long n, void (*p)())
{
	long q;
	int r;

	q = n / 10;
	r = n % 10;

	if(r > 0)
	{
		r -= 10;
		q++;
	}
	
	if(n <= -10)
		printNeg(q,p);
	
	(*p)("0123456789"[-r]);
}

void printNum(long n, void (*p)())
{
	if(n < 0)
	{
		(*p)('-');
		printNeg(n, p);
	}
	else
		printNeg(-n, p);
}
```