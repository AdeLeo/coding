#C陷阱与缺陷
##第一章
###词法分析中的“贪心法”
&emsp;每一个符号应该包含尽可能多的字符。
> 如果(编译器的)输入流截止至某个字符之前都已经被分解为一个个符号，那么下一个符号将包括从该字符之后可能组成一个符号的最长字符串。

**需要注意的是**
除了字符串与字符常量，符号的中间不能嵌有空白（空格符、制表符和换行符）。例如，==是单个符号，而= = 则是两个符号，下面的表达式
`a---b`
与表达式
`a -- - b`
的含义相同，而与在
`a - -- b`
的含义不同。同样的，如果/是为判断下一个符号而读入的第一个字符，而/之后紧接着\*，那么无论上下文如何，这两个字符都将被当做一个符号/\*，表示一段注释的开始。

***
###整型常量
&emsp;如果一个整型常量的第一个字符是数字0，那么该常量将被视作八进制数。因此10和010的含义截然不同
***
###字符和字符串
&emsp;用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。
&emsp;用双引号引起的字符串，代表的确是一个指向无名数组起始字符的指针，该数组被双引号之间的字符以及一个额外的二进制值为零的字符'\0'初始化
`char *slash = '/';`
在编译时将会生成一条错误信息，因为'/'并不是一个字符指针。

整型数（一般为16位或32位）的存储空间可以容纳多个字符（一般为8位），因此有的C编译器允许在一个字符常量（以及字符串常量）中包括多个字符。也就是所，用'yes'代替"yes"不会被该编译器检测到

> 在Borland c++ v5.5和LCC v3.6中采取的做法时，忽略多余的字符，最后的整数值即第一个字符的整数值；而在Visual C++ 6.0和GCC v2.95中采取的做法是，依次用后一个字符覆盖前一个字符，最后得到的整数值即最后一个字符的整数值

***
##第二章
###理解函数声明
`(*fp)()`
ANSI C标准允许程序员将上式简写成fp()，但是一定要记住这种写法只是一种简写形式
在表达式(\*fp)()中，\*fp两侧的括号非常重要，因为函数运算符()的优先级高于单目运算符\*。
***
###运算符的优先级问题
`if(flags & FLAG != 0)`
上式是一个错误的语句。因为!=运算符的优先级要高于&运算符，所以上式实际上被解释为：
`if(flags & (FLAG != 0))`

`r = hi << 4 + low;`
加法运算的优先级要比移位运算的优先级高
因此实际上上式相当于：
`r = hi << (4 + low);`

优先级最高者其实并不是真正意义上的运算符，包括：数组下标、函数调用操作符各结构成员选择操作符。它们都是从左往右结合
**() [] -> .**

单目运算符的优先级仅次于上述运算符。在所有的真正意义上的运算符中，它们的优先级最高。因为函数调用的优先级要高于单目运算符的优先级，所以如果p使一个函数指针，要调用p所指向的函数，必须这样写：(\*p)()。如果写成\*p()，

**单目运算符是自右往左结合，因此*p++会被编译器解释成\*(p++)**

优先级比单目运算符要低的，接下来就是双目运算符，双目运算符中，**算术运算符**的优先级最高，**移位运算符**次之，**关系运算符**再次之，接着是**逻辑运算符**，**赋值运算符**，最后是**条件运算符**。

我们需要记住最重要的两点：
> 1. 任何一个逻辑运算符的优先级低于任何一个关系运算符
> 2. 移位运算符的优先级比算术运算符要低，但是比关系运算符要高。

***
##语义“陷阱”
###整数溢出
C语言中存在两类整数算术运算，有符号运算与无符号运算。如果算术运算符的一个操作数是有符号整数，另一个是无符号整数，那么有符号整数会被转换成无符号整数。当两个操作数都是有符号整数时，“溢出”就可能发生，而且“溢出”的结果时未定义的。当一个运算的结果发生“溢出”时，做出任何假设都是不安全的。

例如:
假定a和b使两个非负整型变量，我们需要检查a+b是否会“溢出”。一种想当然的方式是：
`
if (a + b < 0)
	complain();
`

这并不能正常运行。当a+b确实发生“溢出”时，所有福安雨结果如何的假设都不在可靠。

一种正确的方式是将a和b都强制转换成无符号整数：
`if((unsigned)a + (unsigned)b > INT_MAX) complain();`

不需要用到无符号算术运算的另一种可行方法是：
`if(a > INT_MAX - b) complain();`


##连接
###什么是连接器
C语言中的一个重要思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。

典型的连接器把编译器或汇编器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。

连接器通常把目标模块看成是由一组外部对象组成的。每个外部对象代表着机器内存中的某个部分，并通过一个外部名称来识别。因此，程序中的每个函数和每个外部变量，如果没有被声明为static，就都是一个外部对象。

大多数连接器都禁止同一个载入模块中的两个不同外部对象拥有相同的名称。然而，在多个目标模块整合成一个载入模块时，这些目标模块可能就包含了同名的外部对象。连接器的一个重要工作就是处理这类命名冲突。

处理命名冲突的最简单编发就是干脆完全禁止。对于外部对象时函数的情形，这种做法当然正确，一个程序如果包括两个同名的不同函数，编译器根本就不应该接收。而对于外部对象时变量的情形，问题就变得有些困难了。不同的连接器对这种情形有着不同的处理方式。

连接器的输入时一组目标模块和库文件。连接器的输出时一个载入模块。连接器读入目标模块和库文件，同时生成载入模块。对每个目标模块中的每个外部对象，连接器都要检查载入模块，看是否已经有同名的外部对象。如果没有，连接器就将该外部对象添加到载入模块中；如果有，连接器就要开始处理命名冲突。

除了外部对象之外，目标模块中还可能包括了对其他模块中的外部对象的引用。在连接器生成载入模块的过程中，它必须同时记录这些外部对象的引用。当连接器读入一个目标模块时，它必须解析出这个目标模块中定义的所有外部对象的引用，并做出标记说明这些外部对象不再是未定义的。

###检查外部类型
假定一个C程序，有两个源文件组成。一个文件中包含外部变量n的声明：
`extern int n;`
另一个文件包含外部变量n的定义：
`long n;`
这里假定两个语句都不在任何一个函数体内，因此n使外部变量。
这是一个无效的C程序，因为同一个外部变量名在两个不同文件中被声明为不同的类型。
然而，大多数C语言实现却不能检测出这种错误。

当这个程序运行时，发生什么情况呢？
1、 C语言编译器足够“聪明”，能够检测到这一类型冲突。
2、 C语言实现对int类型的数值与long类型的数值在内部表示上时一样的。尤其时在32位计算机上，一般都是如此处理。在这种情况下，程序很可能正常工作，就好像n在两个文件中都被声明为long(或int)类型一样。
3、 变量n的两个实例虽然要求的存储空间的大小不同，但是它们共享存储哦你关键的方式却恰好能够满足这样的条件：赋给其中一个的值，对另一个也是有效的。这是很可能发生的。
4、 变量n的两个实例共享存储空间的方式，使得对其中一个赋值时，其效果相当于同时给另一个赋值了完全不同的值。在这种情况下，程序将不能正常工作。

##库函数
###返回整数的getchar函数

```
#include <stdio.h>

main()
{
	char c;
	
	while((c = getchar()) != EOF)
		putchar(c);
}
```
getchar函数在一般情况下返回的是标准文件中的下一个字符，当没有输入时返回EOF。

程序中的c使char类型，而不是int类型。这意味着c无法容下所有可能的字符，特别是，可能无法容下EOF

可能发生的情况：
一种是某些合法的输入字符在被“截断”后使得c的取值和EOF一样；另一种可能时，c根本不可能取得EOF这个值。

###更新文件顺序
为了保持与过去不能同时进行读写操作的程序的向下兼容性，一个输入操作不能随后直接紧跟一个输出操作，反之亦然。如果要同时进行输入和输出操作，必须在其中插入fseek函数的调用

```
FILE *fp;
struct record rec;
...
while(fread((char *)&rec, sizeof(rec), 1, fp) == 1)
{
	/*对rec执行某些操作*/
	if(/*rec必须被重新写入*/)
	{
		fseek(fp, -(long)sizeof(rec), 1);
		fwrite((char *)&rec, sizeof(rec), 1, fp);
	}
}
```

这段代码仍然可能运行失败

问题出在：
如果一个记录需要被重新写入文件，也就是说，fwrite函数得到执行，对这个文件执行的下一个操作将是循环开始的fread函数。因为在fwrite函数调用和fread函数调用之间缺少了一个fseek函数调用，所以无法进行上述操作。解决办法是：
```
while(fread((char *)&rec, sizeof(rec), 1, fp) == 1)
{
	/*对rec执行某些操作*/
	if(/*rec必须被重新写入*/)
	{
		fseek(fp, -(long)sizeof(rec), 1);
		fwrite((char *)&rec, sizeof(rec), 1, fp);
		fseek(fp, 0L, 1);
	}
}
```

第二个fseek函数虽然看上去什么也没做，但它改变了文件的状态，使得文件现在可以正常的进行读取了。

###缓冲输出与内存分配
程序输出有两种方式：一种是即时处理方式，另一种是先暂时存起来，然后大块写入的方式，前者往往造成较高的系统负担。

这种控制能力一般是通过库函数setbuf函数实现的。如果buf是一个大小适当的字符数组，那么

`setbuf(stdout, buf);`

语句将通知输入/输出库，所有写入到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区，直到buf缓冲区被填满或者程序员直接调用fflush（对于由写操作打开的文件，调用fflush将导致输出缓冲区的内容被实际地写入该文件），buf缓冲区中的内容才实际写入stdout中。缓冲区的大小由系统头文件<stdio.h>中的BUFSIZ定义。

```
#include <stdio.h>

main()
{
	int c;
	char buf[BUFSIZ];
	setbuf(stdout, buf);
	
	while((c = getchar()) != EOF)
	{
		putchar(c);
	}
}
```

这个程序是错的
因为程序中对库函数setbuf的调用，通知了输入/输出库所有字符的标准输出应该首先缓存在buf中。要找到问题出自何处，我们不妨思考一下buf缓冲区最后一次被清空是在什么时候？答案是在main函数结束之后，作为程序交回控制给操作系统之前C运行时库所必须进行的清理工作的一部分。但是，在此之前buf字符数组已经被释放了！

要解决这种类型的错误有两种办法：
第一种办法是让缓冲数组称为静态数组，既可以直接显式声明buf为静态：
`static char buf[BUFSIZ];`
也可以把buf声明完全移到main函数之外。第二种办法是动态分配缓冲区，在程序中不会主动释放分配的缓冲区
```
char *malloc();
setbuf(stdout, malloc(BUFSIZ));
```

如果malloc函数调用失败，将返回一个空指针。setbuf函数的第二个参数取值可以为空指针，此时标准输出不需要缓冲。在这种情况下，程序仍然能够工作，只不过速度比较慢而已。

###库函数signal
在许多C语言实现中，信号是真正意义上的“异步”。从理论上说，一个信号可能在c程序执行期间的任何时刻发生。需要特别强调的是，信号甚至可能出现在某些复杂库函数（如malloc）的执行过程中。因此，从安全的角度考虑，信号的处理函数不应该调用上述类型的库函数。

例如，假设malloc函数的执行过程被一个信号打断。此时，malloc函数用来跟踪可用内存的数据结构可能只有部分被更新。如果signal处理函数在调用malloc函数，结果可能时malloc函数用到的数据结构signal处理函数的唯一安全、可移植的操作就是打印一条错误消息，然后使用longjmp或exit立即退出程序。

